# GitHub Actions CI/CD Pipeline for Avalanche
# 
# This workflow:
# - Builds and tests the .NET application on every push/PR
# - Generates code coverage reports  
# - Deploys to Azure Web App when release tags are pushed
# 
# Required secrets for deployment:
# - AZURE_TENANT_ID: Azure AD tenant ID
# - AZURE_CLIENT_ID: Application (client) ID for OIDC  
# - AZURE_SUBSCRIPTION_ID: Azure subscription ID

name: CI Pipeline

on:
  push:
    branches: [ main, feature/** ]
    tags: [ 'release*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      use_terraform:
        description: 'Use Terraform instead of Bicep for infrastructure deployment'
        required: false
        type: boolean
        default: false

env:
  DOTNET_VERSION: '8.0.x'
  CONFIGURATION: Release
  COVERAGE_DIRECTORY: ./coverage-results
  COVERAGE_REPORT_DIRECTORY: ./coverage-report
  MIN_COVERAGE_THRESHOLD: 4  # Demo code coverage threshold

jobs:
  build-and-test:
    name: Build, Test & Coverage
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for better analysis

    - name: where am I
      run: tree

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Cache NuGet packages
      uses: actions/cache@v4  
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json', '**/Directory.Packages.props') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore ./Avalanche.sln
      
    - name: Build solution
      run: dotnet build ./Avalanche.sln --configuration ${{ env.CONFIGURATION }} --no-restore

    - name: Security scan with .NET security analyzer
      run: |
        echo "Checking .NET version..."
        dotnet --version
        
        echo "Checking for vulnerable packages..."
        
        # Try the modern approach first
        if dotnet list package --vulnerable --include-transitive 2>/dev/null; then
          echo "✅ No known vulnerabilities found"
        else
          exit_code=$?
          echo "Exit code: $exit_code"
          
          if [ $exit_code -eq 1 ]; then
            echo "⚠️  Vulnerabilities found in dependencies"
            echo "::warning::Vulnerable packages detected - review the output above"
          else
            echo "ℹ️  Vulnerability scanning not available or failed (this is non-blocking)"
            echo "Consider using alternative security scanning tools"
          fi
        fi

    - name: Run tests with coverage
      run: |
        dotnet test ./AvalancheComments.Tests/AvalancheComments.Tests.csproj \
          --configuration ${{ env.CONFIGURATION }} \
          --no-build \
          --verbosity normal \
          --collect:"XPlat Code Coverage" \
          --logger:"trx;LogFileName=test-results.trx" \
          --logger:"console;verbosity=detailed" \
          --results-directory ${{ env.COVERAGE_DIRECTORY }} \
          -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover,cobertura

    - name: Install ReportGenerator
      run: dotnet tool install --global dotnet-reportgenerator-globaltool

    - name: Generate coverage report
      run: |
        reportgenerator \
          -reports:"${{ env.COVERAGE_DIRECTORY }}/**/coverage.cobertura.xml" \
          -targetdir:"${{ env.COVERAGE_REPORT_DIRECTORY }}" \
          -reporttypes:"Html;HtmlSummary;Cobertura;MarkdownSummaryGithub;Badges" \
          -title:"Avalanche Coverage Report" \
          -verbosity:"Info"

    - name: Check coverage threshold
      run: |
        # Check if cobertura.xml exists and extract coverage from it
        if [ -f "${{ env.COVERAGE_DIRECTORY }}"/**/coverage.cobertura.xml ]; then
          coverage=$(grep -o 'line-rate="[0-9.]*"' "${{ env.COVERAGE_DIRECTORY }}"/**/coverage.cobertura.xml | head -1 | grep -o '[0-9.]*')
          coverage_percent=$(echo "$coverage * 100" | bc -l | cut -d. -f1)
        else
          # Fallback: try to extract from text summary if it exists
          if [ -f "${{ env.COVERAGE_REPORT_DIRECTORY }}/Summary.txt" ]; then
            coverage_percent=$(grep -oP 'Line coverage: \K[0-9.]+' "${{ env.COVERAGE_REPORT_DIRECTORY }}/Summary.txt" || echo "0")
          else
            echo "No coverage files found, defaulting to 0%"
            coverage_percent=0
          fi
        fi
        
        echo "Code coverage: ${coverage_percent}%"
        if (( coverage_percent < ${{ env.MIN_COVERAGE_THRESHOLD }} )); then
          echo "::error::Code coverage ${coverage_percent}% is below threshold ${{ env.MIN_COVERAGE_THRESHOLD }}%"
          exit 1
        fi
        echo "✅ Coverage ${coverage_percent}% meets minimum threshold of ${{ env.MIN_COVERAGE_THRESHOLD }}%"

    - name: Display coverage summary
      if: always()
      run: |
        if [ -f "${{ env.COVERAGE_REPORT_DIRECTORY }}/SummaryGithub.md" ]; then
          cat "${{ env.COVERAGE_REPORT_DIRECTORY }}/SummaryGithub.md" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Comment PR with coverage
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const coverageFile = '${{ env.COVERAGE_REPORT_DIRECTORY }}/SummaryGithub.md';
          if (fs.existsSync(coverageFile)) {
            const coverage = fs.readFileSync(coverageFile, 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Coverage Report\n${coverage}`
            });
          }

    - name: Publish AvalancheComments
      if: success()  # Only publish if tests pass
      run: |
        dotnet publish ./AvalancheComments/AvalancheComments.csproj \
          --configuration ${{ env.CONFIGURATION }} \
          --output ./publish \
          --no-build \
          --no-restore

    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      if: success()  # Only upload if build succeeds
      with:
        name: avalanche-app-${{ github.sha }}
        path: ./publish/
        retention-days: 30
        if-no-files-found: error

    - name: Upload coverage results (raw)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-results-${{ github.sha }}
        path: ${{ env.COVERAGE_DIRECTORY }}
        retention-days: 30
        if-no-files-found: warn

    - name: Upload coverage report (HTML)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-report-html-${{ github.sha }}
        path: ${{ env.COVERAGE_REPORT_DIRECTORY }}
        retention-days: 30
        if-no-files-found: warn

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ github.sha }}
        path: ${{ env.COVERAGE_DIRECTORY }}/**/*.trx
        retention-days: 30
        if-no-files-found: warn

  package-infra:
    name: Package Infrastructure
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        sparse-checkout: |
          infra/
        sparse-checkout-cone-mode: true

    - name: Install Bicep CLI
      run: az bicep install

    - name: Lint Bicep files
      working-directory: ./infra
      run: |
        echo "Linting Bicep files..."
        for bicep_file in *.bicep; do
          if [ -f "$bicep_file" ]; then
            echo "Linting $bicep_file"
            az bicep build --file "$bicep_file" --stdout > /dev/null
            echo "✅ $bicep_file passed linting"
          fi
        done
        echo "All Bicep files passed linting successfully!"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3.1.2
      with:
        terraform_wrapper: false

    - name: Lint Terraform files
      working-directory: ./infra/terraform
      run: |
        echo "Linting Terraform files..."
        terraform init -backend=false
        terraform validate
        terraform fmt -check -recursive
        echo "✅ All Terraform files passed linting!"

    - name: Upload infrastructure artifact
      uses: actions/upload-artifact@v4
      with:
        name: infra-${{ github.sha }}
        path: ./infra/
        retention-days: 30
        if-no-files-found: error

  security-scan:
    name: Security Analysis
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write  # Required for CodeQL
      actions: read           # Required for CodeQL
    steps:
    - uses: actions/checkout@v4
    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v4
      with:
        languages: csharp
    - name: Autobuild
      uses: github/codeql-action/autobuild@v4
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v4
        
  deploy:
    name: Deploy to Azure WebApp
    needs: [build-and-test, package-infra, security-scan]
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/release')) || (github.event_name == 'workflow_dispatch')
    environment:
      name: production
      url: ${{ steps.deploy-infra.outputs.webAppUrl }}
    permissions:
      contents: read
      id-token: write
      deployments: write
    steps:
    - name: Download build artifact
      uses: actions/download-artifact@v4
      with:
        name: avalanche-app-${{ github.sha }}
        path: ./publish

    - name: Download infrastructure artifact
      uses: actions/download-artifact@v4
      with:
        name: infra-${{ github.sha }}
        path: ./infra

    - name: Login to Azure using OIDC
      uses: azure/login@v1
      with:
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Setup Terraform
      if: github.event_name == 'workflow_dispatch' && inputs.use_terraform == true
      uses: hashicorp/setup-terraform@v3.1.2
      with:
        terraform_wrapper: false

    - name: Run Terraform deployment
      if: github.event_name == 'workflow_dispatch' && inputs.use_terraform == true
      id: deploy-infra-terraform
      working-directory: ./infra/terraform
      env:
        ARM_USE_OIDC: true
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      run: |
        chmod +x infra-terraform.sh
        ./infra-terraform.sh

    - name: Run Bicep deployment
      if: github.event_name != 'workflow_dispatch' || inputs.use_terraform != true
      id: deploy-infra-bicep
      working-directory: ./infra
      run: |
        chmod +x infra.sh
        ./infra.sh

    - name: Set deployment outputs
      id: deploy-infra
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ inputs.use_terraform }}" == "true" ]; then
          echo "webAppName=${{ steps.deploy-infra-terraform.outputs.webAppName }}" >> "$GITHUB_OUTPUT"
          echo "webAppUrl=${{ steps.deploy-infra-terraform.outputs.webAppUrl }}" >> "$GITHUB_OUTPUT"
        else
          echo "webAppName=${{ steps.deploy-infra-bicep.outputs.webAppName }}" >> "$GITHUB_OUTPUT"
          echo "webAppUrl=${{ steps.deploy-infra-bicep.outputs.webAppUrl }}" >> "$GITHUB_OUTPUT"
        fi

    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ steps.deploy-infra.outputs.webAppName }}
        package: ./publish
      
    - name: Record deployment tag
      run: |
        echo "Deployed tag ${GITHUB_REF#refs/tags/} to production"
        echo "Web App URL: ${{ steps.deploy-infra.outputs.webAppUrl }}"
